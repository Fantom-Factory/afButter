Overview [#overview]
********************
'Butter' is a library that helps ease HTTP requests through a stack of middleware.

'Butter' is a replacement for `web::WebClient` and provides an extensible chain of middleware for making HTTP requests and
processing the response.
The adoption of the Middleware pattern allows you to seamlessly enhance and modify the behaviour of your HTTP requests.
See `OpenAuthMiddleware` for an example.

'Butter' was inspired by Ruby's [Faraday]`https://github.com/lostisland/faraday` library.



Install [#Install]
******************
Install 'Butter' with the Fantom Repository Manager ( [fanr]`http://fantom.org/doc/docFanr/Tool.html#install` ):

  $ fanr install -r http://repo.status302.com/fanr/ afButter

To use in a [Fantom]`http://fantom.org/` project, add a dependency to 'build.fan':

  depends = ["sys 1.0", ..., "afButter 0+"]



Quick Start [#quickStart]
*************************
1). Create a text file called 'Example.fan':
pre>
using afButter

class Example {
    Void main() {
        butter   := Butter.churnOut()
        response := butter.get(`http://www.fantomfactory.org/`)
        echo(response.asStr)
    }
}
<pre

2). Run Example.fan as a Fantom script from the command line:
pre>
C:\> fan Example.fan
<!DOCTYPE html>
<html>
    <head>
        <title>Home :: Fantom-Factory</title>
        ....
        ....
<pre



Usage [#usage]
**************
An instance of `Butter` wraps a stack of [Middleware]`ButterMiddleware` classes. When a HTTP request is made through
'Butter', each piece of middleware is called in turn. Middleware classes may either pass the request on to the next
piece of middleware, or return a response. At each step, the middleware classes have the option of modifying the request
and / or response objects.

The ordering of the middleware stack *is* important.

The last piece of middleware *MUST* return a response. These middleware classes are called *Terminators*. The default
terminator is the `HttpTerminator` which makes an actual HTTP request to the interweb. (When testing this could be
substituted with a mock terminator that returns set / canned responses.)

To create a 'Butter' instance, call the static [Butter.churnOut()]`Butter.churnOut` method, optionally passing in a custom
list of middleware:

pre>
  middlewareStack := [
    StickyCookiesMiddleware(),
    StickyHeadersMiddleware(),
    OpenAuthMiddleware(),
    FollowRedirectsMiddleware(),
    ErrOn5xxMiddleware(),
    HttpTerminator()
  ]

  butter := Butter.churnOut(middlewareStack)
<pre

Or to use the default stack of middleware bundled with 'Butter', just *churn and go*:

pre>
  html := Butter.churnOut.get(`http://www.fantomfactory.org/`).asStr
<pre



Butter Dishes [#butterDish]
***************************
Because functionality is encapsulated in the middleware, you need to access these classes to configure them.
Use the [Butter.findMiddleware()]`Butter.findMiddleware` method to do this:

pre>
  butter := Butter.churnOut()
  ((FollowRedriectsMiddleware) butter.findMiddleware(FollowRedriectsMiddleware#)).enabled = false
  ((ErrOn5xxMiddleware) butter.findMiddleware(ErrOn5xxMiddleware#)).enabled = false
<pre

As you can see, this code is quite verbose. To combat this, there are two alternative means of getting hold of middleware:

Dynamic Stylie [#dynamic]
=========================
If you make dynamic invocation method calls on the 'Butter' class, you can retrieve instances of middleware.
The dynamic methods have the same simple name as the middleware type. If the type name ends with 'Middleware', it may be
omitted. Example:

pre>
  butter := Butter.churnOut()
  butter->followRedriects->enabled = true
  butter->errOn5xx->enabled = true
<pre

Should instances of the same middleware class be in the stack more than once (or should it contain 2 middleware classes
with the same name from different pods) then the just first one is returned.

Obviously, dynamic invocation should be used with caution.

Static Stylie [#static]
=======================
To call the middleware in a statically typed fashion, use a 'ButterDish' class that holds your 'Butter' instance and
contains helper methods.
There is a default `ButterDish` class with methods to access middleware in the default stack. Example:

pre>
  butter := ButterDish(Butter.churnOut())
  butter.followRedirects.enabled = true
  butter.errOn5xx.enabled = true
<pre

When using other middleware, you are encouraged to create your own 'ButterDish' that extends the default one.



Release Notes [#releaseNotes]
*****************************

v0.0.4 [#v0.0.4]
----------------
 - New: Added 'ErrOn4xxMiddleware' to cacth those annoying 404s!
 - Chg: Support for HTTP resposne headers that may appear multiple times, e.g. 'Set-Cookie'
 - Chg: Renamed 'ButterRequest.data()' -> 'stash()'.
 - Bug: Could not post case-insensitive forms - see [Uri.encodeQuery throws UnsupportedOperationException]`http://fantom.org/sidewalk/topic/2236`

v0.0.2 [#v0.0.2]
----------------
 - New: Preview Release